{
  "version": 3,
  "sources": ["../src/retry.ts"],
  "sourcesContent": ["export interface IRetryOptions {\n    /**\n     * The number of times to retry the operation. Default is 3.\n     */\n    maxRetries?: number\n    /**\n     * The base amount of time to use in the exponential backoff formula.\n     * Default is 1000 (1 second) (maxRetries * baseBackoffMs must be\n     * less than 30 seconds).\n     */\n    retryDelayType?: 'fixed' | 'exponential'\n    /**\n     * The base number of milliseconds to use in the exponential backoff\n     * for operation retries. Default is 1000 (1 second).\n     * @default 1000 \n     * @example\n     * // The default value of `1000` will result in the following delays\n     * // between retries: 1s, 2s, 4s.\n     * // To disable exponential backoff, set `baseDelay` to `0`.\n     * @example\n     * // To set a custom delay sequence, set `baseDelay` to an appropriate\n     * // value. The following will result in delays of 1s, 6s, 11s.\n     * baseDelay: 1000,\n     * maxRetries: 3\n     */\n    retryDelay?: number\n    /**\n     * maxDelay: The maximum number of milliseconds to use in the exponential backoff\n     * for operation retries. Default is 60,000 (1 minute).\n     * @default 60000\n     * @example\n     * // The default value of `60000` will cap exponential backoff delays at 1 minute.\n     * // To disable the maximum delay, set `maxDelay` to `Infinity`.\n     */\n    maxRetryDelay?: number\n}\n\nexport interface IRetryOperator<T> {\n    (...args: any[]): Promise<T>\n    /**\n     * \n     * @param reason The reason for aborting the operation.\n     * @returns\n     * \n     * @example\n     * let counter = 0\n     * let promise = retryPromiseFactory(() => {\n     *      counter += 1;\n     *      if (counter === 3) {\n     *          return Promise.resolve();\n     *      }\n     * })\n     * promise().then(() => {\n     *   console.log('Operation succeeded!')\n     * }).catch((err) => {\n     *    console.log('err: ', err)\n     * })\n     * setTimeout(() => {\n     *  promise.abort?.('abort')\n     * }, 1000)\n     */\n    abort?(reason?: any): void\n}\n\n/**\n *  Retry an operation with exponential backoff.\n * @param ms  The number of milliseconds to delay.\n * @returns \n */\nexport const delay = (ms: number): Promise<void> => new Promise(resolve => setTimeout(resolve, ms))\n\n\n/**\n *  Retry an operation with exponential backoff.\n * @param {IRetryOperator} operation - The operation to retry.\n * @param {IRetryOptions} [options] - The retry settings.\n * @returns {Promise} A promise that resolves when the operation succeeds.\n * let counter = 0\n * let promise = retryPromiseFactory(() => {\n *      counter += 1;\n *      if (counter === 3) {\n *          return Promise.resolve();\n *      }\n * })\n * promise().then(() => {\n *   console.log('Operation succeeded!')\n * }).catch((err) => {\n *    console.log('err: ', err)\n * })\n */\nexport const retryPromiseFactory = <T>(fn: (...args: any[]) => Promise<T>, options?: IRetryOptions): IRetryOperator<T> => {\n    const { maxRetries = 3, retryDelay = 1000, maxRetryDelay = 60000, retryDelayType = 'exponential' } = options || {}\n\n    let abort: ((reason?: any) => void) | undefined\n    const operation = (...args: any[]) => {\n        return new Promise<T>(async (resolve, reject) => {\n            let retries = 0\n\n            abort = (reason: any) => {\n                /**\n                 * break the loop\n                 */\n                retries = maxRetries\n                reject(reason)\n            }\n            while (retries < maxRetries) {\n                try {\n                    const result = await fn(...args)\n                    return resolve(result)\n                } catch (err) {\n                    if (retries >= maxRetries) {\n                        return reject(err)\n                    }\n                    const delayTime = retryDelayType === 'exponential' ? Math.min(Math.pow(2, retries) * retryDelay, maxRetryDelay) : retryDelay\n                    retries++\n                    await delay(delayTime)\n                }\n            }\n            return reject({ message: 'Retry failed' })\n        })\n    }\n\n    /**\n     * if you want to abort the operation, you can call this method\n     * but if you want to abort the operation, you should call operation before call this method\n     * @param reason  The reason for aborting the operation.\n     * @returns\n     */\n    operation.abort = (reason?: any) => {\n        abort?.(reason)\n        /**\n         * reset abort\n         */\n        abort = undefined\n    }\n\n    return operation\n}\n"],
  "mappings": "6MAqEO,IAAMA,EAASC,GAA8B,IAAI,QAAQC,GAAW,WAAWA,EAASD,CAAE,CAAC,EAqBrFE,EAAsB,CAAIC,EAAoCC,IAA+C,CACtH,GAAM,CAAE,WAAAC,EAAa,EAAG,WAAAC,EAAa,IAAM,cAAAC,EAAgB,IAAO,eAAAC,EAAiB,aAAc,EAAIJ,GAAW,CAAC,EAE7GK,EACEC,EAAY,IAAIC,IACX,IAAI,QAAW,CAAOV,EAASW,IAAWC,EAAA,wBAC7C,IAAIC,EAAU,EASd,IAPAL,EAASM,GAAgB,CAIrBD,EAAUT,EACVO,EAAOG,CAAM,CACjB,EACOD,EAAUT,GACb,GAAI,CACA,IAAMW,EAAS,MAAMb,EAAG,GAAGQ,CAAI,EAC/B,OAAOV,EAAQe,CAAM,CACzB,OAASC,EAAP,CACE,GAAIH,GAAWT,EACX,OAAOO,EAAOK,CAAG,EAErB,IAAMC,EAAYV,IAAmB,cAAgB,KAAK,IAAI,KAAK,IAAI,EAAGM,CAAO,EAAIR,EAAYC,CAAa,EAAID,EAClHQ,IACA,MAAMf,EAAMmB,CAAS,CACzB,CAEJ,OAAON,EAAO,CAAE,QAAS,cAAe,CAAC,CAC7C,EAAC,EASL,OAAAF,EAAU,MAASK,GAAiB,CAChCN,GAAA,MAAAA,EAAQM,GAIRN,EAAQ,MACZ,EAEOC,CACX",
  "names": ["delay", "ms", "resolve", "retryPromiseFactory", "fn", "options", "maxRetries", "retryDelay", "maxRetryDelay", "retryDelayType", "abort", "operation", "args", "reject", "__async", "retries", "reason", "result", "err", "delayTime"]
}
